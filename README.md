# Создаём первое приложение на vue.js

1. Создаём папку проекта
2. index.html
3. подключаем vue через cdn в шапке страницы, так же как в предыдущих уроках
4. в теле страницы создаём:

        <div id="app"></div>
5. Инициализируем приложение в файле script.js

          var app = new Vue({})
6. задаём идентификатор приложения и его название в блоке data

        var app = new Vue({
        el: '#app',
        data: {
          title: 'notes App',
        },
        methods: {
        },
        computed: {

        },
      })
7. Выводим заголовок приложения на странице:

        <div id="app">
          <div class="wrapper">
            <h1> {{ title }} </h1>
          </div>
        </div>

## Работаем с data

1. Создаём массив. Он будет содержать в себе заметки. Это объекты: заголовок, описание, дата публикации. В полноценном приложении эти заметки подтягиваются из базы данных, но сейчас мы начинаем с малого и будем добавлять заметки вручную.

2. Продублируем еще две заметки, для наглядности.

## Создаём структуру вывода заметок на странице - добавляем классы

1. В теле приложения (на странице) создаём новый тег с классом notes. В этом теге будут выводиться все наши заметки.

        <div class="notes"></div>

2. Внутрь вкладываем еще один тег, в который будем выводить отдельную заметку:

        <div class="notes">
                <div class="note" v-for="(note, index) in notes" :key="index">

                </div>
        </div>

3. В параметрах тега с классом note прописываем параметры:

   - v-for="(note, index) in notes" (директива используется для отрисовки списков. Имеет особый синтаксис записи: item in items, где items — исходный массив, а item — ссылка на текущий элемент массива).
   - :key="index" (атрибут, который позволяет идентифицировать с какими именно элементами нужно работать. Обычно используется в связке с директивой v-for).

    В этом конкретном случае в качестве атрибута ключа у нас выступает индекс элемента в массиве.

4. Создаём следующий вложенный тег с классом note__header:

        <div class="notes">
          <div class="note" v-for="(note, index) in notes" :key="index">
            <div class="note__header"> </div>
          </div>
        </div>

5. Добавим вывод данных нашей заметки:

        <div class="notes">
            <ul class="note" v-for="(note, index) in notes" :key="index">
              <li class="note__header">
                <h3> {{ note.title }} </h3>
                <p> {{ note.description }} </p>
                <hr>
                <time> {{ note.date }} </time>
              </li>
            </ul>
        </div>

6. Смотрим как отрабатывает наше приложение в браузере:

![как отработало приложение в браузере - простой список заметок](/demo/Screenshot_1.jpg)

## Реализуем функционал добавления новой заметки в приложение

1. В структуру html добавляем новый тег с классом new-note в котором размечаем элементы формы для ввода данных - поля ввода и кнопка отправки.

        <div class="new-note">
          <label for="">Введите заголовок заметки</label>
          <input type="text" name="" id="" placeholder="Ваше название">

          <textarea name="" id="" cols="30" rows="10">Текст заметки</textarea>
          <button type="submit">Добавить заметку</button>
        </div>

2. Немного стилизуем внешний вид по средствам css и получаем вот такой внешний вид ![новые элементы для добавления заметки](/demo/Screenshot_2.jpg)

3. В скрипте приложения добавляем новый объект для сохранения заметок:

      note: {
            title: '',
            description: ''
          },
4. В разметке приложения добавляем параметры:

        <div class="new-note">
          <label for="">Введите заголовок заметки</label>
          <input type="text" name="" id="" placeholder="Ваше название" v-model="note.title">

          <textarea name="" id="" cols="30" rows="10" v-model="note.description">Текст заметки</textarea>
          <button type="submit" @click="addNote">Добавить заметку</button>
        </div>
5. Создаём новый метод AddNote, для функционала добавления заметки в массив:

      methods: {
          addNote () {
            console.log(this.note);
          }
        },
  и выведем данные в консоль.

6. Смотрим как приложение отработало в консоли браузера: ![вывод данных в консоли](/demo/Screenshot_3.jpg)

7. Настраиваем передачу даты в новую заметку

   Для этого доработаем наш метод:

        addNote () {
          this.notes.push({
            title: this.note.title,
            description: this.note.description,
            date: new Date(Date.now()).toLocaleString()
          })
        }

8. Смотрим как приложение отработало в браузере. Как видно из скриншота, заметка добавилась в массив. Правда пока что без даты: ![вывод данных в консоли](/demo/Screenshot_4.jpg)

9. Упрощаем запись метода используя современный стандарт ES6 и переменную в которой сохраняем повторяющееся выражение:

          addNote () {
          let {title, description} = this.note;
          this.notes.push({
            title,
            description,
            date: new Date(Date.now()).toLocaleString()
          })
        }

## Валидация

Для более правильной = логичной работы приложения давайте доработаем наш метод добавления новой заметки.
Обезопасим себя от бесконечных публикаций пустых заметок (когда пользователь ничего не вводит и просто нажимает на кнопку Добавить заметку), а так же проверку заполненности заголовка формы.

1. Для этого доработаем метод - добавим в него условие, которое проверяет пуст ли заголовок новой заметки в форме:

        addNote () {
      let {title, description} = this.note;
      if (title === '') {
        return false;
      }
      this.notes.push({
        title,
        description,
        date: new Date(Date.now()).toLocaleString()
      })
    }

   Теперь мы не можем опубликовать пустую заметку.

2. Добавим вывод сообщения об ошибке, что бы пользователь нажимая на кнопку, при отправке пустой заметки, понимал, что что то не так :)

   1. В основных данных приложения добавляем:

          var app = new Vue({
            el: '#app',
            data: {
              title: 'Мои заметки',
              message: null,
              note: {
                title: '',
                description: '',
                date: ''
              },
   2. В разметке нашего приложения добавляем новый тег классом message для вывода сообщения об ошибке.

            <div class="message" v-if="message">
              <p> {{ message }} </p>
            </div>
   3. Дописываем условие проверки поля заголовка в методе addNote:

          if (title === '') {
              this.message = 'Заголовок заметки не может быть пустым!'
              return false;
            }
   4. После завершения добавления заметки в методе добавляем параметр для сообщения, который переопределит текст сообщения на значение пусто:

            addNote () {
            let {title, description} = this.note;

            if (title === '') {
              this.message = 'Заголовок заметки не может быть пустым!'
              return false;
            }

            this.notes.push({
              title,
              description,
              date: new Date(Date.now()).toLocaleString()
            })

            this.message = null
            this.note.title = ''
            this.note.description = ''
          }

### Как это работает?

По умолчанию у нас под заголовком есть пустой блок с выводом текста ошибки. в теле разметки мы прописали условие:  v-if="message".

>Директива v-if используется для рендеринга блока по условию. Блок будет отображаться только в том случае, если выражение директивы возвращает значение, приводимое к true.

Так как значение сообщения у нас в приложении по умолчанию nan - мы ничего не выводим.

Как только значение меняется, а мы в условии проверки поля, присваиваем значение в виде текста - выводим его в приложении: ![вывод данных в консоли](/demo/Screenshot_5.jpg)

После того как пользователь исправился и заполнил наконец то поле заголовка - мы добавляем заметку в массив, и меняем текст сообщения на null
И очищаем поля в форме, присваивая им пустые значения.

## Какие проблемы есть у нашего приложения?

1. нет возможности контролировать версию Vue, которая подключается через ссылку в head
2. В структуре нашего приложения отсутствуют template используемые для вывода компонентов приложения. И из за этого мы пишем скрипты в одном общем js-файле.

Давайте сделаем наше приложение более удобным для масштабирования и отладки.
Для этого нам понадобиться изучить Vue CLI

